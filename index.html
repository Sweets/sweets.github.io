<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="description" content="lost in walmart blog">
		<title>lost in walmart blog</title>
		<link rel="stylesheet" type="text/css" href="/master.css">
	</head>
	<body>
		<header>
			<nav>
				<a href="#0x01">help, i'm lost in walmart</a>
				<a href="https://github.com/Sweets">github</a>
			</nav>
			<iframe sandbox="allow-scripts allow-top-navigation" loading=lazy src="https://circle.comfi.es/f/lost-in-walmart.blog/"></iframe>
		</header>
		<hr>
		<a id="0x08"></a>
		<article>
			<h3><span>0x08</span> &mdash; <i>misunderstood</i></h3>
			<p>
				For whatever reason, macOS is very badly misunderstood in the context of *nix users.
				<br>
				I'm not quite sure why that is, honestly. In the same sense that linux is *nix, macOS is very much also *nix.
				<br>
				<br>
				I've got the 2021 MacBook Pro, which has the new M1. I really wanted to play around with the new CPU,
				<br>
				but also branch out a bit more. I've developed for macOS before, not to say that I had amazing projects for it,
				<br>
				but I'm not new to it. What I am new to though is owning a real mac. Previously I just would use a Hackintosh install
				<br>
				when I had a Ryzen 3 2200G and an RX550.
				<br>
				Lovely hardware combination for <a href="https://amd-osx.com/" target="_blank">macOS</a>, I'd say.
				<br>
				<br>
				Anyways, the M1 is actually extremely powerful I've found. Many others have found this news before me,
				<br>
				but to my surprise, it almost competes with my 3950x in single core performance.
				<br>
				I'm not quite sure whether that's the raw horsepower of the CPU at work, or if it's the amazing optimization Apple
				<br>
				is known for, or if it's the ARM architecture grinding. Regardless, at its core, it's still running macOS.
				<br>
				Which very indirectly is based on UNIX.
				<br>
				<br>
				So why in a community of UNIX-like systems does it receive so much hate?
				<br>
				I think it's just misunderstood. Very badly at that.
				<br>
				For what it's worth, macOS has <i>amazing</i> system level APIs.
				<br>
				Like, incredibly good. Security is <u>not</u> an afterthought on macOS, and it shows. I'm not going to pretend
				<br>
				there haven't been any vulnerabilities before, but unlike a lot of Linux distributions, everything is built with
				<br>
				intent. Something that Linux suffers a lot from.
				<br>
				<br>
				In macOS, the developers convenience is not at the expense of the end-users usability, nor security.
				<br>
				The root file system, for example, is not mounted as r/w, it's ro. If it ever is mounted as such, it's with <i>intent</i>.
				<br>
				Something many Linux distribution should take notes on.
				<br>
				<br>
				On top of this, it's just as customizable as Linux distributions are. You can change out as much or as little as you want.
				<br>
				The options are limited, but that's because the same crowd of neckbeards writing window managers and compositors
				<br>
				for Linux are not the same crowd using macOS. There's very little overlap.
				<br>
				<br>
				Another thing is that much of the system is event driven. I know the programmers out there are starting to lose their minds.
				<br>
				If you've ever had to program something that requires you to test conditionals, but you don't have any direct API,
				<br>
				you probably had to use an infinite loop. Which kills CPU usage. Maybe you could poll, but what if there's no file descriptors?
				<br>
				<br>
				Realistically, I can see money as an argument against macs. But like previously brought up, you can do Hackintoshes.
				<br>
				If you intend on doing one, you'll find you're restricted in the exact hardware necessary because drivers don't exist for everything.
				<br>
				<br>
				If you can do it though, it's definitely a fun project to take up, and not a bad daily driver.
				<br>
				If you don't like it, you don't like it. People will find every reason in the world to dislike something, except for
				<br>
				their own personal tastes. For whatever reason, they just can't say "there's nothing wrong with it, I just don't like it."
				<br>
				<br>
				To summarize, I see no reason why macOS receives the hate it does. It's just badly misunderstood.
			</p>
		</article>
		<hr>
		<a id="0x07"></a>
		<article>
			<h3><span>0x07</span> &mdash; <i>systemdo or systemdon't</i></h3>
			<p>
				Often times in the *nix community, people will tell you things like "systemd is bad" and that you shouldn't use it.
				<br>
				Then they will go on a triad of reasons why systemd is bad.
				<br>
				Now, to any normal or informed user, some of these arguments against systemd may be considered valid.
				<br>
				But to any other user, in particular users new to *nix, these are horribly misleading reasons to use something other than systemd.
				<br>
				The latter crowd is who this blog entry is for.
				<br>
				<br>
				Systemd calls itself a "software suite." So, as such, it provides many tools--few of which are actually simple--that are useful in the runtime of the operating system.
				<br>
				None of systemd's components are inherently bad.
				<br>
				The problem with systemd is that the entirety of the software suite is executed as pid 1.
				<br>
				The first process is the one that on many systems is the init system. It is the highest parent process in the hierarchy, as it is executed by the kernel.
				<br>
				Now in some applications, this is what you may want. You may want a reliable and battle tested process running as the init, especially on servers.
				<br>
				You may even want it on a desktop as well, for ease of use.
				<br>
				The biggest problem with being told what init to use and what not to use is that what works for others may not work for you.
				<br>
				<br>
				A lot of people have asked me what init they should use. The simplest answer, use the one that works. If systemd works for your system, why replace it?
				<br>
				On top of that, some distributions of Linux almost hard depend on systemd. For example, <a href="https://archlinux.org/" target="_blank">Arch Linux</a>, where the entire
				<br>
				system is built on the premise of using systemd. Packages that are installed have appropiate unit files for systemd. Replacing it, while it can be done,
				<br>
				is a tidious and quite annoying process.
				<br>
				<br>
				So all of this is to say: if you're the user who is new to *nix, and you don't know what init to use, don't change your init at all.
				<br>
				To quote a friend of mine, "<i>Linux users are all about freedom of choice, right up until someone's choice differs from theirs</i>."
				<br>
				<br>
				And on the opposite side of the spectrum, if you're the redbilled based user who is preaching to the newer, pure linux users:
				<br>
				<i>Shut the fuck up</i>. Let them learn the pros or cons of the software themselves. After all, for as much as I dislike systemd myself, <i>it just works</i>.
			</p>
		</article>
		<hr>
		<a id="0x06"></a>
		<article>
			<h3><span>0x06</span> &mdash; <i>a love letter to forums</i></h3>
			<p>
				Time goes on, technology is innovated upon, but when I was younger, I was enthralled by forums.
				<br>
				I don't know the particulars of it, but there's something oddly satisfying about creating a post on a board, and having to sit and refresh the page several times until you get a response.
				<br>
				<br>
				That's something that nowadays technology has taken from us.
				<br>
				Why would people want to sit on a forum, create a post asking how to fix a problem or spark some sort of conversation when they can go on Discord and get a response damn near instantly?
				<br>
				Call it what you want, patience, delayed gratification--whatever the case may be, forums have a certain charm to them.
				<br>
				And while I appreciate a good quick response from time to time, or a quick catch-up conversation with old friends over instant messaging,
				<br>
				I have a much larger appreciation for simple forums.
				<br>
				<br>
				In the forum community, it's hard to draw people in. It's hard to entice people to join in on something so primitive and outdated.
				<br>
				Maybe I just live in the past, but even today I still slay bits and bytes on good old bulletin boards.
				<br>
				Hell, if you look hard enough, you might even find forums that I'm still an active keyboard warrior on.
			</p>
		</article>
		<hr>
		<a id="0x05"></a>
		<article>
			<h3><span>0x05</span> &mdash; <i>a fictional story about timestamp gore</i></h3>
			<p>
				A long time ago, in a server far far away existed a web developer and a really interesting codebase. You are our savior in this story.
				<br>
				When you typically think of timestamps, chances are you think of a UNIX timestamp.
				<br>
				A 32-bit integer counting the amount of seconds that have passed since January 1st, 1970.
				<br>
				<br>
				Storing timestamps seems like a relatively painless endeavor, just allocate enough space for the timestamp, and you're off to the race(condition)s.
				<br>
				Except maybe it isn't the best implementation. I mean, some time in early 2038 UNIX timestamps will overflow, and we'll need to either switch to 64 bit or create a new epoch.
				<br>
				<br>
				It'll basically be Y2K all over again. 0x7fffffff16 will be our demise! Or will it?
				<br>
				Realistically speaking, likely not. What is more likely is developers will start implementing fixes for this overflow before it actually happens, and we won't be ill prepared.
				<br>
				<br>
				But what about another solution? What if we stored timestamps as a string?
				<br>
				Well, this can be an implementation, and depending on how scalable you want your timestamps to be, maybe the best way to deal with this kind of issue.
				<br>
				So, as a little bit of a thought experiment, if we did this, how much space would we need to allocate for our string?
				<br>
				<br>
				To calculate something like this, we'll need to make some assumptions. Typically, information on a website is stored in a database, and often times it's in SQL.
				<br>
				In a UTF8 encoded db, a single character is given 4 bytes of memory. If we use type varchar(32) to store a timestamp as a string, we'll have 128 bytes to work with.
				<br>
				128 bytes doesn't necessarily sound like a lot, but that's only for a single row. A single record.
				<br>
				If we say... store user data, to include when a user registered... Well, now we have N * 128 bytes of storage being taken up, where N is the amount of users, assuming we store no other information of course.
				<br>
				<br>
				You see where I'm going with this, right? So just 8 users deep, and all of the sudden we're taken up a kilobyte of storage for <i>just</i> timestamps.
				<br>
				By the way, do you like gore? I sure hope so.
				<br>
				Imagine for a moment that instead of storing a timestamp as a string in only a single column, we split up each part into its own dedicated column.
				<br>
				Let's be conservative and say that we give each indice... 6 characters to work with at most. And we'll say we only need the seconds, minutes, hours, days, months, and years.
				<br>
				Alright, we've got 6 columns, each of them have 6 characters. Remember, one single character takes up 4 bytes. 4 * 6 * 6. Now our timestamps take up 144 bytes.
				<br>
				<br>
				So given our algorithm of N * 144, we hit 1kb at just 7 users. Not that much of a difference, but we sure won't fucking scale well at all.
				<br>
				Now we're taking a metric ass-ton (abbreviated as AT) of space for <i>only</i> timestamps. We haven't even stored more than one, and we didn't calculate storage space for any other columns.
				<br>
				So by the time we add everything else back in, our user table is now taking up more than an AT. We're now taking kilo-ass-tons of storage space. kAT.
				<br>
				<br>
				So we're taking severak kATs of space, and we haven't even considered actual usage with this.
				<br>
				Time to query the database.
			</p>
			<pre>SELECT `seconds`,`minutes`,`hours`,`days`,`months`,`years`,`uid`,`username`,... FROM `pain_and_suffering.users` WHERE 1;</pre>
			<p>
				Could you imagine having to write that query several times over?
				<br>
				Don't worry, you don't have to, because in our fictional story, Bill did it for you.
				<br>
				Bill got fired by the way. Google didn't like how badly their database was running. And it's your lucky day, because site-wide, you get to fix this.
				<br>
				Oh, no, Google isn't running a query generator or anything. They haven't moved onto more modern technologies yet because they don't know how secure something like Laravel is or isn't.
				<br>
				<br>
				This might be a good time to mention that if we just used the datetime column type--which only uses 8 bytes--we would only be at N * 8. We'd hit 125 user records before we hit a kilobyte.
				<br>
				Just some food for thought; we haven't even hit a single AT of taken up storage space yet by using the datetime type.
				<br>
				<br>
				You've been tasked now with fixing every database query, as well as every bit of source code that deals with Bill's original database schema.
				<br>
				So what do you do? You start a transaction.
				<br>
				Time to write up a bit of code that iterates over every record in the database, parses each column related to time, concatenates it all, converts it to a proper UNIX timestamp,
				<br>
				stores it properly, then stores it in the database. Then you make sure everything is good, commit to the database, or rollback if not.
				<br>
				<br>
				Don't get me wrong; I'm not saying that storing a timestamp as a string is necessarily a bad thing, but don't be like Bill and assume it's going to be the best approach.
				<br>
				<br>
				Thankfully this story is <i>only</i> fictional. I pity the person who once had to, or one day will have to, fix this completely fictional issue.
				<br>
				Remember, kids, <i>sometimes the best approach is the one most used</i>. We don't all need to be innovators.
			</p>
		</article>
		<hr>
		<a id="0x04"></a>
		<article>
			<h3><span>0x04</span> &mdash; <i>close the window, i'm programming</i></h3>
			<p>
				You know, being in quite a few *nix customization communities, and also developing programs primarily for Linux, people often ask me, "Why the fuck do you use Windows?"
				<br>
				Don't worry, the irony is not lost on me. I may be smoov brane, but I'm not senile. Not yet at least.
				<br>
				<br>
				Now there's a lot of reasons I use it. The most common one I give is that <i>I think</i> linux is a waste of good hardware.
				<br>
				Take that how you will, but I've used linux for a <i>very</i> long time. That being the case though, as far back as I can remember using it, it was only ever prominently on old laptops or machines with weaker hardware.
				<br>
				Any average linux user will tell you it's because "linux gives your computer a performance boost!", which itself is wrong. Linux just doesn't use as many resources as another operating system, like Windows.
				<br>
				You have no actual performance gain as you otherwise would, it's just it seems like that to the end user because of these freed resources.
				<br>
				<br>
				The next reason is simply I don't like babysitting my system anymore. I think it may because I'm getting older as the days go on, but I don't like doing package management anymore,
				<br>
				I don't like having to go on a witch hunt for a bug and I can't use my shell anymore because I did a partial system upgrade, and now I have to burn it at the stake because bash depends on readline, and bash can't use the version of readline on my system.
				<br>
				It's mostly beyond me now, I've done it before, I'm tired of doing it, so I don't want to do it again.
				<br>
				<br>
				Next, I grew out of my customization phase. Don't get me wrong, I love doing desktop customization, and I do dabble in it every full blue moon, but that's only in passing now.
				<br>
				I no longer just sit down for hours on in trying to find the "optimal" setup. It's kind of like building a computer or working on a project car. You may get done with it, but it's never <i>complete</i>.
				<br>
				<br>
				Now if any of these reasons apply to you, that's completely fine. There's nothing wrong with having old hardware, nothing wrong with babysitting a system,
				<br>
				and there's nothing wrong with wanting to customize your system unless you use i3. These are just my reasons.
				<br>
				<br>
				This still begs the question though, "Sweets... you use Windows, yet you develop for Linux? What are you smoking, and where can I get some?"
				<br>
				To answer your second question, I'm not smoking no matter how hard that may be to believe, and then to answer your first, yes.
				<br>
				Alright, good talk. See you later.
				<br>
				<br>
				In all seriouesness, I still love Linux, despite not using it myself. I especially love developing for it because, simply, it's fun for me. There's no rhyme or reason.
				<br>
				I just enjoy it. And hopefully you or others enjoy using what I make. Even if you don't, at the end of the day, I program for fun (and thank fuck I don't program for a living now, I can tell some horror stories about that).
				<br>
				<br>
				So yeah, next time someone calls me a retard in a certain "down" Discord server, I'll just refer them here.
				<br>
				And if you're that person; go fuck yourself, there's nothing wrong with using Windows, despite what the insects living in your neckbeard tell you.
				<br>
				Also take a shower.
			</p>
		</article>
		<hr>
		<a id="0x03"></a>
		<article>
			<h3><span>0x03</span> &mdash; <i>help, i'm lost in walmart</i></h3>
			<p>
				After some bouncing of domains off of the forehead of a certain box, I've finally decided on what I want to call my blog.
				<br>
				A common tagline I've used on various social medias is "Help, I'm lost in Walmart."
				<br>
				This mostly stems from my inability to think up bios and such, but it's stuck for quite some time.
				<br>
				<br>
				So what better to call my blog than the lost in walmart blog? My blog isn't strictly tech related, just a blog for me to write whatever comes to mind.
				<br>
				<br>
				So officially; <i>help, I'm lost in Walmart</i>.
				<br>
				<br>
				On another note, you may notice in the top right a "previous" and "next" button.
				<br>
				The lost in walmart blog is part of a webcircle, the links go to various sites of my friends, and at some point, back here eventually.
				<br>
				Check out the other sites in the circle, I'm sure something that piques your interest can be found.
			</p>
		</article>
		<hr>
		<a id="0x02"></a>
		<article>
			<h3><span>0x02</span> &mdash; <i>__always_inline, linux, and musl</i></h3>
			<p>
				If you're trying to install <a href="https://k1sslinux.org" target="_blank">kiss linux</a> (or any non-glibc distribution) with a linux 5.x kernel, you may find that you'll run into an error trying to build the kernel.
			</p>
			<pre>/usr/include/linux/byteorder/little_endian.h:44:8: error: unknown type name '__always_inline'</pre>
			<p>
				On a system running glibc, this isn't particularly an issue; __always_inline is defined.
				<br>
				This isn't the case on systems that are using <a href="https://www.musl-libc.org/" target="_blank">musl</a> or other libc's though.
				<br>
				<br>
				So, as a quick fix, open up /usr/include/linux/swab.h in your flavor of text editor, and include linux/stddef.h just below linux/types.h.
			</p>
			<pre>#include &lt;linux/types.h&gt;
#include &lt;linux/stddef.h&gt;</pre>
			<p>
				With that, try to build again and you should be up an running.
				<br>
				Several PRs have been made in regards to this issue, so hopefully this will be fixed soon.
			</p>
		</article>
		<hr>
		<a id="0x01"></a>
		<article>
			<h3><span>0x01</span> &mdash; <i>pure of heart, dumb of ass</i></h3>
			<p>
				So this is my "blog" of sorts. A little about me, about the work I do, my system, etc.
				<br>
				<br>
				I'm Grayson, I go by Sweets on the internet. I'm 20 years old, born in Texas, I now live in California.
				<br>
				My background is in full stack web development, though I don't work as a developer anymore, now I'm just a lowly C hobbyist.
				<br>
				Now I work as a microminiature repair technician. I solder super tiny circuits and shit.
				<br>
				<br>
				I believe in clean, readable code. I'm known for a various projects in *nix communities, <a href="https://github.com/Sweets/tiramisu" target="_blank">tiramisu</a>, <a href="https://github.com/Sweets/hummingbird" target="_blank">hummingbird</a>, and <a href="https://github.com/comfies/custard" target="_blank">custard</a> just to name a few.
				<br>
				<br>
				Some information on my systems, my desktop is a custom build that I've named "mercury".
				<br>
				I've got a Ryzen 9 3950x @ 4.5GHz, an RTX 2070 Super, Sabrent Rocket Q4 4TB, an Asus Strix B550-I, all housed within the beautiful <a href="https://formdworks.com/products/t1" target="=_blank">formd T1</a>.<br>
				My primary operating system is Windows 10, which is where I do all of my development. And yes, I see the irony in that.
				<br>
				My laptop is a 2021 MacBook Pro 13". The fancy M1 one because I have a bad habit of spending copious amounts of money on unnecessary hardware.
				<br>
				When I do use Linux, I use <a href="https://k1sslinux.org" target="=_blank">kiss linux</a> and <a href="https://www.debian.org/" target="_blank">debian</a>.
				<br>
				<br>
 				Some communities that I frequent are r/<a href="https://reddit.com/r/unixporn" target="_blank">unixporn</a> and r/<a href="https://reddit.com/r/sffpc" target="_blank">sffpc</a>.
			</p>
		</article>
	</body>
</html>
