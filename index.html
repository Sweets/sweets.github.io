<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="description" content="lost in walmart blog">
		<title>lost in walmart blog</title>
		<link rel="stylesheet" type="text/css" href="/master.css">
	</head>
	<body>
		<header>
			<nav>
				<a href="#0x01">help, i'm lost in walmart</a>
				<a href="https://github.com/Sweets">github</a>
			</nav>
			<iframe sandbox="allow-scripts allow-top-navigation" loading=lazy src="https://circle.comfi.es/f/lost-in-walmart.blog/"></iframe>
		</header>
		<hr>
		<a id="0x11"></a>
		<article>
			<h3><span>0x11</span> &mdash; <i>why I've been gone</i></h3>
			<p>
				I said in the last blog post you wouldn't see me in a year. Well, surprise, it's 2022, and I haven't seen y'all since last year.
				<br>
				<br>
				I can feel you cringing from that joke.
				<br>
				<br>
				I've been taking a break from programming lately. It's kind of been depressing me quite a bit.
				<br>
				I've mentioned this here before, but every now and then I get burnt out on programming, and when I'm like that I get pretty depressed.
				<br>
				Sometimes it just feels like I have an obligation to my GitHub, which just isn't the case. So every now and then I force myself off.
				<br>
				<br>
				I'm still not quite back on the grind yet, but this entry is more of an "I'm alive, stop messaging me on Discord you daft bastards" entry.
				<br>
				I mean, I don't particularly mind messaging over Discord, but I do know that some people read this blog. It escapes me as to why.
				<br>
				Anyways, I'm alive.
				<br>
				<br>
				I did say I would disappear for quite a bit to play some new games, and that I absolutely have.
				<br>
				This week and all last week when I wasn't at work, I put my sigma grindset dedication into Pokemon Brilliant Diamond.
				<br>
				How much of that grindset, you ask? Well let me put it this way. There's 488 obtainable pokemon in the game, and of those 488
				<br>
				I have actually caught and in my storage box a whopping 476. I'm completing my national dex this weekend.
				<br>
				Yeah, I had to catch them all.
				<br>
				<br>
				I've also, like I've said I would, been playing the absolute <i>fuck</i> out of Forza Horizon 5.
				<br>
				You know, some people don't like racing games, and that's fine. One of my friends didn't understand--
				<br>
				He asked me why would I want to play a game where I drive a bunch of cars I can't in real life. And that's the point.
				<br>
				I will say, it's probably good that it isn't real life. My poor Porsche 911 GT3 in FH5 would have easily been turned inside out by now.
				<br>
				<br>
				Other major life updates I suppose, I did recently catch the Kung Flu-19. That's right ladies and gentlemen, I had the cheese touch.
				<br>
				I'm fine now, did my little quarantine shin-dig, got better, what have you. I knew I had it when I woke up a 3:30 in the morning one day
				<br>
				with a <i>pounding</i> headache. Unfortunate because the very day prior I was drinking 805s with friends as we were all gathered
				<br>
				around my television watching anime. Luckily of the five of us goons that were at my place, only one other got covid.
				<br>
				<br>
				Also, another lovely development: I went over to <a href="https://www.pslatecustoms.com/" target="_blank">pslate customs</a> and bought $230 worth of custom cables for my computer.
				<br>
				Your immediate reaction to this is probably "What the fuck?" or "What a waste of money."
				<br>
				To those I would repsond that pslate customs has extremely high quality sleeved cables they make, AND they're fitted to your case (which is perfect if you use small form factor),
				<br>
				and fuck you it's my money and this is capitalism at it's finest, and if you don't like me spending my money that I earn then you give me minimum 50k a year and tell me how to spend it.
				<br>
				<br>
				Eventually I'm doing a full cooling upgrade on my computer. I say "eventually I'm doing" and not "I'm planning to" because I already have everything I need.
				<br>
				Got my radiator, my tubing, got my new CPU block, hell, even got my GPU block from EK. I just haven't... done it yet. I'll get to it. It's not that I don't have time, I'm just playing Pokemon still.
				<br>
				<br>
				Speaking of, the new Legends Arceus game is coming out, and I've been hawkeying the shit out of the leaks. It looks amazing. There's some new pokemon forms I'm not entirely kosher with, but
				<br>
				I'll just get the fuck over it. I already pre-ordered the game anyways. Funny because in my whole lifetime I've pre-ordered only 3 games. Call of Duty Black Ops 2, and Pokemon BDSP and Legends Arceus.
				<br>
				Maybe I'm a fucking nerd.
				<br>
				<br>
				Anyways, you've been on this blog entry long enough, it's time you started paying rent. That or move onto the next entry. Smell you later, nerd.
				<br>
				And yes, that is a Pokemon reference.
			</p>
		</article>
		<hr>
		<a id="0x10"></a>
		<article>
			<h3><span>0x10</span> &mdash; <i>you won't see me for a year</i></h3>
			<p>
				Just as a quick reminder if you've been following my blog,
				<br>
				this is a <i>personal</i> blog. I've been writing a lot about programming
				<br>
				lately, but it's time to switch speeds a little bit.
				<br>
				<br>
				I'm going to be a huge fucking nerd here, but Q4 2021 and then all of 2022 looks
				<br>
				amazing for video games.
				<br>
				<br>
				Right now I've got a huge list of games that I am <u>going</u> to buy and play.
				<br>
				Not in any particular order, Pokemon Legends Arceus, Pokemon Brilliant Diamond/Shining Pearl,
				<br>
				Dead Space (that's right ladies, Dead Space is finally getting a mother fucking remake), Forza Horizon 5,
				<br>
				Callisto Protocol, Elden Ring, Splatoon 3, Breath of the Wild 2 electric boogaloo, and A Plague Tale: The Squeaquel.
				<br>
				<br>
				As far as announced games, that's what I've got on my list so far. I'm a huge fan of the Pokemon series,
				<br>
				generation 4 in particular. Dead Space is my favorite video game series of all time.
				<br>
				I'm also a huge Forza Horizon fan. The other games that are continuations are games I've thoroughly enjoyed--
				<br>
				my reasons go on and on. But it's been <i>years</i> since I've been this excited about video games.
				<br>
				In recent years gaming has been largely disappointing.
				<br>
				<br>
				Yeah, sure, some games I've hawkeyed until release, like Nier Replicant and Luigi's Mansion 3.
				<br>
				But nothing has really <i>grabbed</i> me, if you know what I mean.
				<br>
				<br>
				I just bought a Nintendo Switch, again. Solely for Pokemon Legends. Yeah, BDSP is enticing, but it's not my main
				<br>
				attraction. I still have Platinum on an actual DS (currently shiny hunting Cresselia, by the way. Have been since December 2020).
				<br>
				I sold my old Switch because I barely played it. Now look at me.
				<br>
				<br>
				TL;DR you're going to see milk cartons with my face on them captioned with "Missing Person."
				<br>
				Gaming is absolutely going to be a hobby I pick back up. Soon, too, since the Pokemon Diamond and Pearl remakes are
				<br>
				a whopping 13 days away now.
				<br>
				<br>
				Also yet another year that this is the year of Sonic the Hedgehog. It never really is, but supposedly a new Sonic
				<br>
				game is coming out. If it has a Chao garden I'll pick it up. If not, I won't. That's basically
				<br>
				how I've been with the blue blur games ever since Unleashed. With the exception of Mania.
				<br>
				The Chao garden in the Adventure series I still play to this day, and the newer Sonic games have not
				<br>
				been good enough for me to even think about picking up, unfortunately.
			</p>
		</article>
		<hr>
		<a id="0x0f"></a>
		<article>
			<h3><span>0x0f</span> &mdash; <i>sometimes being unprepared prepares you the best</i></h3>
			<p>
				I've been programming for 10 years now. In fact, I just hit the 10 year mark.
				<br>
				In my experience, I've found several means of planning.
				<br>
				<br>
				Sometimes I like to board things, sometimes I modularize functionality of something,
				<br>
				hell, even comments to my future self helps.
				<br>
				<br>
				One thing I've come to realize though is sometimes the best way to prepare yourself to write
				<br>
				something is to not prepare at all.
				<br>
				<br>
				Hear me out.
				<br>
				My most recent project, <a>mxfw</a>. The program is entirely just a bridge between a user and macOS' window server,
				<br>
				and users take advantage of the API that it provides.
				<br>
				<br>
				Here's an example of responding to window events for only one specific window type.
				<br>
				<pre>
mx.window { bundle = 'com.apple.Terminal' }
	:on("created", function(window)
		print("Hello, World!")
	end)
	:on("closed", function(window)
		print("Goodbye, World.")
	end)</pre>
				<br>
				<br>
				Now, I spent quite a few days trying to figure out how I would implement that sort of API.
				<br>
				It was actually quite a difficult thing to do because it provides several challenges.
				<br>
				Firstly, the function mx.window(). What should it return?
				<br>
				The obvious answer is some sort of event handler, or something that contains :on().
				<br>
				And yes, that's an obvious one, but look at the actual function call for :on().
				<br>
				It takes two parameters, the event string, and a callback.
				<br>
				Mind you, this has to be implemented in the Objective C++ part of the program.
				<br>
				<br>
				More than that, what if no rule is present?
				<br>
				And since it's in Objective C++, and the Lua API it uses can't explicitly provide transient data
				<br>
				that <i>originated</i> from the parent, then what?
				<br>
				<br>
				In addition to this, how do I store these rules? How do I map them, such that the event emitter
				<br>
				in mxfw knows to <i>only</i> emit an event for this window if the rule applies?
				<br>
				<br>
				These are all very good questions that have been asked. And more importantly, ultimately,
				<br>
				my solution that I ended up implementing was far simpler and more eloquent than what I had boarded out prior.
				<br>
				<br>
				The solution I came up with was that mx.window() was actually just a method that would
				<br>
				create rules and store them in a map. This map would map window rules to a vector of structureas.
				<br>
				Said structures contained two children, an event and a callback. This was, in essence, a map, without the
				<br>
				super large overhead from C++'s STL.
				<br>
				<br>
				When an event for a window is emitted, it checks to see if any rules apply. If they do, then
				<br>
				it looks through the vector of event-callback mappings and looks for the event that was emitted.
				<br>
				If one is found, then it calls the mapped callback. If not, who gives a shit. Discard. Move on.
				<br>
				<br>
				See, the problem wasn't that I wasn't in the right mindset. The problem was that
				<br>
				I was overanalyzing the fuck out of the problem. I was too wrapped around thinking that
				<br>
				the mx.window() function should return some sort of grand object that contained all window data,
				<br>
				or that I needed to have a bitwise AND of all the events that a window responds to and then check a large
				<br>
				look up table and what have you.
				<br>
				<br>
				Moral of the story; the bigger picture was <i>there</i>. And I was thinking too large, too complex.
				<br>
				Even breaking the problem down didn't help me at all.
				<br>
				<br>
				And maybe, just maybe, you're going through something similar to me in concept.
				<br>
				Maybe there's a problem that you just can't figure out cognitively.
				<br>
				<br>
				I'm here to tell you that you don't need to.
				<br>
				Just start writing. The implementation will fall into place.
				<br>
				And if you don't like it, that's fine. At the end of the day, you can always refactor.
			</p>
		</article>
		<hr>
		<a id="0x0e"></a>
		<article>
			<h3><span>0x0e</span> &mdash; <i>i am bad at naming things.</i></h3>
			<p>
				I am bad at naming things.
				<br>
				I am.
				<br>
				It's just a fact of life.
				<br>
				The speed of light is 299,792,458 m/s, the sun will inevitably die, Earth will soon crumble due to human pollution,
				<br>
				California has shitty gas prices, and I... am bad at naming things.
				<br>
				<br>
				To cut to the chase, I've had several projects I've had to rename in the past.
				<br>
				Some more than once. But my most recent project, <i>mxfw</i>, has been renamed five times.
				<br>
				It started out as Opal, then Moonstone, Carbon, Sodium--eventually I just quit trying.
				<br>
				<br>
				<i>mxfw</i> as it is referred to right now, is a framework window manager for macOS. If you live in *nix land or use
				<br>
				X11, think awesome wm but for macOS.
				<br>
				It's been renamed five times. That's ridiculous. It started out as Opal simply because that was the first thing I thought of.
				<br>
				It moved to Moonstone because it uses Lua as its scripting language. I thought it made sense.
				<br>
				Eventually I wasn't a fan of that name because it seemed long and to some degree unmemorable.
				<br>
				Then came Carbon. Users complained that it was called Carbon because Apple already has a library they call Carbon.
				<br>
				For some that was too confusing. Then came Sodium. Turns out, there's a Minecraft mod named Sodium.
				<br>
				The elements theme was because it was supposed to be the building block for a window manager.
				<br>
				<br>
				In the past I've named projects after a quality they have, and if not that, then the first thing that came to mind.
				<br>
				<a href="https://github.com/Sweets/hummingbird" target="_blank">hummingbird</a> was named because hummingbirds are fast, and it's
				<br>
				entire design philosophy is to be a fast init for Linux.
				<br>
				<a href="https://github.com/Sweets/tiramisu" target="_blank">tiramisu</a> was named because I was eating tiramisu at the time I created it.
				<br>
				<br>
				I'm a simple man.<br>
				But alas, a simple man cannot name things. Not that you would expect me to be able to--I'm named after a color.
			</p>
		</article>
		<hr>
		<a id="0x0d"></a>
		<article>
			<h3><span>0x0d</span> &mdash; <i>transpiling is the answer to your problem</i></h3>
			<p>
				It's [<i>insert year here</i>].
				<br>
				You're a brand new developer. A little baby man.
				<br>
				You're special. You're unique. You bring to the table something that literally nobody else does.
				<br>
				You're trying to make your own programming language.
				<br>
				<br>
				Look, I'm not going to be that guy, but I'm going to be that guy. You're not doing anything new by doing this.
				<br>
				"But it will have X! And Y!" Yeah, Z has X and Y, and it does it fifteen times more efficiently than you do, to the point where your
				<br>
				code takes at least 3 business days to execute. News flash, buddy, it's a Friday.
				<br>
				Meanwhile, Z is sending you your executable same day shipping, <i>and it's gift-wrapped</i>.
				<br>
				<br>
				I'm not trying to say that you're not a special snowflake, but at least half of the population has done what you're trying before.
				<br>
				Sometimes it doesn't make sense to reinvent the wheel.
				<br>
				<br>
				Sometimes, instead of compiling directly to unoptimized machine code because you don't know any better,
				<br>
				you may just want to transpile. The wheel has already been made for you, so just make the damn axles already.
				<br>
				<br>
				Now what is transpiling? Well, put simply, instead of going from your code to machine code, you go from your code
				<br>
				to the code of another language, then to machine code.
				<br>
				<br>
				There are benefits to this, there are also drawbacks.
				<br>
				<br>
				First and foremost, your compilation will take much longer. That's just the nature of the beast.
				<br>
				Parallelization is your best friend here.
				<br>
				Next, the code is for the most part optimized already. Someone else already did the heavy lifting. Including carrying you and millions of others
				<br>
				on their backs.
				<br>
				The code immediately becomes much more portable. Especially if you're transpiling to say, C. Everyone and their mother's dog has the ability to compile C programs.
				<br>
				And the last major thing I want to highlight here is that transpiling might be a little bit more difficult.
				<br>
				<br>
				To this, I hear you say, "But Sweets, I'm writing an interpreter. Not a compiler."
				<br>
				Don't worry, you're not doing that correctly either.
				<br>
				Interpreting a language is a much bigger beast than a lot of people take it to be. A lot of people will start writing one, and
				<br>
				just after they've written their lexical analyzer, and tokenizer, and then they'll realize they are up to their knees in shit.
				<br>
				They're doing a handstand right now.
				<br>
				<br>
				At this point, I feel it's important for me to say that the tone of this entry isn't to condescend upon you, the reader, specifically.
				<br>
				I've gone through these same woes in my time, and I've seen plenty of others go through the same ones.
				<br>
				<br>
				So look, at the end of the day, maybe transpiling is the answer to your problem.
				<br>
				What I will say, is maybe it's not though. Maybe LLVM is better for you.
				<br>
				There's a lot of different solutions to making a programming language. My intention in this post is to say that maybe just writing a simple
				<br>
				interpreter or trying to compile to machine code directly might not be your best choice of action.
			</p>
		</article>
		<hr>
		<a id="0x0c"></a>
		<article>
			<h3><span>0x0c</span> &mdash; <i>building blocks</i></h3>
			<p>
				It's been a while, hasn't it? Not that any new user would know, I don't date these things.
				<br>
				I was pretty burnt out on programming for a long while there. Now I'm not so much.
				<br>
				<br>
				Every now and then I become enamered by something new. Or in this case, new to me.
				<br>
				The current obsession I've got is with meson.
				<br>
				<br>
				Now, I've never been one to write good Makefiles. Anyone who knows me knows I don't know the Make syntax.
				<br>
				Not that it's ever bothered me any--but Makefiles are one of those things where everyone does it differently and everyone else is wrong.
				<br>
				<br>
				Conveniently though, there are... better build systems. I mean, Make is nice. But it's old.
				<br>
				Nothing wrong with being crusty and old, but really what this means is newer things are out. And meson is one of them.
				<br>
				I've been trying to learn meson lately. Days of old have passed, no longer am I going to have pull requests made to my GitHub in regards to Makefiles.
				<br>
				Only pull requests about the code. And about my incorrectly made meson files.
				<br>
				<br>
				Anyways, meson seems to be the new in and hip thing. And I've dedicated myself to trying to learn it. One roadblock I've found is that it's very...
				<br>
				lean on language support. Which for me may be a weird hurdle, considering I write projects in languages like <i>Objective</i> C...++.
				<br>
				<br>
				Yes, that's a very specific language to be writing in. It's not without reason, I needed the Objective C layer over just regular C because it's much nicer to use
				<br>
				with a macOS environment, and on top of that, C++'s object oriented nature helps that particular project I use Objective C++ for.
				<br>
				Oh, and let's not forget Vala. I've recently rewritten Tiramisu in Vala. I enjoy the project much more now, but it's a niche language in the grand scheme of things.
				<br>
				<br>
				Look, the programming language gene pool is vast, and C is the Genghis Khan of the pool. Python is the lifeguard, Java is drowning, and Rust and Go are... building sand castles, and kicking each others over every five minutes.
				<br>
				And Meson supports only 4 of these beach-goers. I don't know where this analogy went, but I somehow brought it back.
				<br>
				<br>
				I guess this was a long winded way of me saying--I'm <i>going</i> to figure out a way to build my projects with Meson.
				<br>
				It's cleaner syntactically, faster (by their own metrics at least), and for the love of a God that I don't believe in, people won't have to PR as much for my projects.
				<br>
				Until someone makes another standard. Maybe that'll be my next blog entry. Bullshit standards made by bullshit organizations.
				<br>
				<br>
				Anyways, something something automated build systems something something.
			</p>
		</article>
		<hr>
		<a id="0x0b"></a>
		<article>
			<h3><span>0x0b</span> &mdash; <i>nothing but passion</i></h3>
			<p>
				As many have observed before, it sometimes takes me months to hammer out specific issues or bugs on projects.
				<br>
				Anyone who knows me knows that I don't program for any monetary reasons. I mean, yes, I do have a sponsor button on GitHub,
				<br>
				but I'm completely open to saying that I proudly have 0 sponsors. So realistically, this is all just a hobby for me.
				<br>
				<br>
				That being said, when I work on programs, I do so out of purely passion. I don't work on things I don't like or don't want to,
				<br>
				and more over, if I have to force myself to work on something, I dread it even more.
				<br>
				<br>
				I've said it before, but for as much as I love programming, I fucking hate it. This stems from me working as a developer in the past,
				<br>
				I lost my love for it for a long time, got really burnt out on it.
				<br>
				<br>
				A very long period of time later, I started getting back into programming.
				<br>
				From time to time though, you may notice that I am very slow to fix issues.
				<br>
				In particular, something like <a href="https://github.com/Sweets/tiramisu/issues/20" target="_blank">#20</a> on <a href="https://github.com/Sweets/tiramisu" target="_blank">tiramisu</a>.
				<br>
				Opened October of 2020, closed (for good) July of 2021.
				<br>
				<br>
				The sad reality of it is that I hate tiramisu now, though. I hate working on it, I hate its implementation as I think it could be better, I hate that it has the attention it does,
				<br>
				I just hate the whole project.
				<br>
				So of course it took three-fourths of an eternity for me to work on it. I have to force myself to work on it.
				<br>
				Not to mention that it's a pain in the ass for me to work on it, since I don't have any actual machine running linux, and WSL and dbus don't exactly agree.
				<br>
				So realistically, it's a pain in the dick hole to even begin work on, and then it's a more metaphorical pain in the ass crevice because I don't even <i>want</i> to work on it.
				<br>
				<br>
				Other projects, like <a href="https://github.com/Sweets/hummingbird" target="_blank">hummingbird</a> and <a href="https://github.com/Sweets/Moonstone" target="_blank">Moonstone</a>, however, I still have a burning passion for.
				<br>
				I will say, just because there's been no <i>recent</i> git history on one of my projects doesn't mean I'm sick of working on it and just quitting on it. It could just mean it's actually done. Or, equally likely, I just havent pushed
				<br>
				my local commits any time recently.
				<br>
				<br>
				Whatever the case may be though, just know, all of my projects and products of passion.
			</p>
		</article>
		<hr>
		<a id="0x0a"></a>
		<article>
			<h3><span>0x0a</span> &mdash; <i>a secret scam</i></h3>
			<p>
				Every so often in society, people, businesses, companies even, get caught scamming people.
				<br>
				There's some things in life that are just completely unreasonable to pay for.
				<br>
				Maintenance on your car (I'm a firm beliver that everyone should do their own car work, but I'm also a car guy so my opinion is worthless),
				<br>
				scalped computer hardware, the cost of Pokemon games for the GameBoys and Nintendo DS', but worst of all, beef <i>fucking</i> jerky.
				<br>
				<br>
				Hear me out. Everywhere from San Diego, CA and Dallas, TX, Jack Links Beef Jerky is a fat $5 for ~3oz. They're not the only offenders, though.
				<br>
				Other brands are worse. More money for less meat.
				<br>
				<br>
				Now the more astute among you may pin the blame for the high price on smoking the beef (or meat in general, in the case of non-beef jerky),
				<br>
				on the spices, quality assurance, but none of that matters.
				<br>
				It's all bullshit because to make beef jerky, all you do is just spice and smoke.
				<br>
				<br>
				When you can get much higher quality beef for just $10 per pound, that's 16oz of good meat.
				<br>
				This means that you pay just a bit over 3x for jack links that you would just buying meat yourself.
				<br>
				<br>
				Wake up, sheeple. Big beef doesn't want you to know this.
				<br>
				Jerk your own beef.
			</p>
		</article>
		<hr>
		<a id="0x09"></a>
		<article>
			<h3><span>0x09</span> &mdash; <i>keyboards</i></h3>
			<p>
				Recently I've been wanting to get into making a custom keyboard. I love building things, and one of the things I've never gotten into before is clickity click clack machines
				<br>
				But I'm having a hard time justifying it.
				<br>
				<br>
				Now whenever I get into something, I <i>get into it</i>. I research for several hours different parts, components, the benefits of some versus others,
				<br>
				no choice I ever make is without hours of learning. Which I quite like.
				<br>
				<br>
				For some peculiar reason though, in the days, if not weeks now, of my looking into different PCBs, different layouts, switches, and keycaps,
				<br>
				I haven't been able to justify making one.
				<br>
				<br>
				At the end of the day, a keyboard is just a means of input for my computer. More specifically for my desktop, since I use my laptop as an actual laptop.
				<br>
				Alright, so what's the hold up? Well, keyboard builds come out to over $200 typically. I've got a keyboard that I paid $40 for.
				<br>
				<br>
				They both accomplish the <i>same</i> thing, but one for a drastically different price.
				<br>
				"One has a much better typing experience!" You say, and to that I say that I don't actually feel the difference... at all.
				<br>
				The nerves to my fingers may not be firing correctly or something, because despite what many scream, I feel no difference at all.
				<br>
				I mean, sure, the individual key caps may be different, but the actuation feels no different to me. Which is ideally what I want to feel different.
				<br>
				<br>
				"But the sound! The custom one will sound so much better!" You begin to cry out.
				<br>
				I don't hear a difference. The only time I hear any difference at all is when someone drowns the stabilizers in lubricant.
				<br>
				<br>
				Alright, well maybe the layout is what I would benefit from.
				<br>
				Nope, not one fucking bit. I use all of the keys on my keyboard. <i>All of them</i>.
				<br>
				I use the numpad regularly, I use my home/end and page up/down keys when programming, which I do regularly,
				<br>
				I use my function keys as media controls... I use every key no the keyboard. Even system request. Try me.
				<br>
				<br>
				Anyways, I see no value in building a custom keyboard. I wish I did.
				<br>
				I really want to build one. But I can't justify to myself spending the amount of money one costs to build,
				<br>
				when I have a perfectly good one.
				<br>
				<br>
				On the other hand, there are more things I really want to get into with keyboards.
				<br>
				In particular, I'm very interested in stenography.
				<br>
				<br>
				If you aren't aware of what stenography is, neither was I. In essence, stenography is the use of a special keyboard
				<br>
				that has keys for phonetic sounds. So instead of pressing individual letters to write out a word,
				<br>
				you press the beginning phonetic sound, the ending sound, and the keyboard fills in the spaces in between.
				<br>
				<br>
				That explanation was a little simplified, in actuality it's a little more complex than just that,
				<br>
				but it's a really interesting means of typing. The actual purpose of stenography is for stenographers,
				<br>
				someone who transcribes speech, typically in the court of law.
				<br>
				<br>
				Maybe one day I'll build a keyboard. And maybe it'll be a steno keyboard.
				<br>
				Who knows.
			</p>
		</article>
		<hr>
		<a id="0x08"></a>
		<article>
			<h3><span>0x08</span> &mdash; <i>misunderstood</i></h3>
			<p>
				For whatever reason, macOS is very badly misunderstood in the context of *nix users.
				<br>
				I'm not quite sure why that is, honestly. In the same sense that linux is *nix, macOS is very much also *nix.
				<br>
				<br>
				I've got the 2021 MacBook Pro, which has the new M1. I really wanted to play around with the new CPU,
				<br>
				but also branch out a bit more. I've developed for macOS before, not to say that I had amazing projects for it,
				<br>
				but I'm not new to it. What I am new to though is owning a real mac. Previously I just would use a Hackintosh install
				<br>
				when I had a Ryzen 3 2200G and an RX550.
				<br>
				Lovely hardware combination for <a href="https://amd-osx.com/" target="_blank">macOS</a>, I'd say.
				<br>
				<br>
				Anyways, the M1 is actually extremely powerful I've found. Many others have found this news before me,
				<br>
				but to my surprise, it almost competes with my 3950x in single core performance.
				<br>
				I'm not quite sure whether that's the raw horsepower of the CPU at work, or if it's the amazing optimization Apple
				<br>
				is known for, or if it's the ARM architecture grinding. Regardless, at its core, it's still running macOS.
				<br>
				Which very indirectly is based on UNIX.
				<br>
				<br>
				So why in a community of UNIX-like systems does it receive so much hate?
				<br>
				I think it's just misunderstood. Very badly at that.
				<br>
				For what it's worth, macOS has <i>amazing</i> system level APIs.
				<br>
				Like, incredibly good. Security is <u>not</u> an afterthought on macOS, and it shows. I'm not going to pretend
				<br>
				there haven't been any vulnerabilities before, but unlike a lot of Linux distributions, everything is built with
				<br>
				intent. Something that Linux suffers a lot from.
				<br>
				<br>
				In macOS, the developers convenience is not at the expense of the end-users usability, nor security.
				<br>
				The root file system, for example, is not mounted as r/w, it's ro. If it ever is mounted as such, it's with <i>intent</i>.
				<br>
				Something many Linux distribution should take notes on.
				<br>
				<br>
				On top of this, it's just as customizable as Linux distributions are. You can change out as much or as little as you want.
				<br>
				The options are limited, but that's because the same crowd of neckbeards writing window managers and compositors
				<br>
				for Linux are not the same crowd using macOS. There's very little overlap.
				<br>
				<br>
				Another thing is that much of the system is event driven. I know the programmers out there are starting to lose their minds.
				<br>
				If you've ever had to program something that requires you to test conditionals, but you don't have any direct API,
				<br>
				you probably had to use an infinite loop. Which kills CPU usage. Maybe you could poll, but what if there's no file descriptors?
				<br>
				<br>
				Realistically, I can see money as an argument against macs. But like previously brought up, you can do Hackintoshes.
				<br>
				If you intend on doing one, you'll find you're restricted in the exact hardware necessary because drivers don't exist for everything.
				<br>
				<br>
				If you can do it though, it's definitely a fun project to take up, and not a bad daily driver.
				<br>
				If you don't like it, you don't like it. People will find every reason in the world to dislike something, except for
				<br>
				their own personal tastes. For whatever reason, they just can't say "there's nothing wrong with it, I just don't like it."
				<br>
				<br>
				To summarize, I see no reason why macOS receives the hate it does. It's just badly misunderstood.
			</p>
		</article>
		<hr>
		<a id="0x07"></a>
		<article>
			<h3><span>0x07</span> &mdash; <i>systemdo or systemdon't</i></h3>
			<p>
				Often times in the *nix community, people will tell you things like "systemd is bad" and that you shouldn't use it.
				<br>
				Then they will go on a triad of reasons why systemd is bad.
				<br>
				Now, to any normal or informed user, some of these arguments against systemd may be considered valid.
				<br>
				But to any other user, in particular users new to *nix, these are horribly misleading reasons to use something other than systemd.
				<br>
				The latter crowd is who this blog entry is for.
				<br>
				<br>
				Systemd calls itself a "software suite." So, as such, it provides many tools--few of which are actually simple--that are useful in the runtime of the operating system.
				<br>
				None of systemd's components are inherently bad.
				<br>
				The problem with systemd is that the entirety of the software suite is executed as pid 1.
				<br>
				The first process is the one that on many systems is the init system. It is the highest parent process in the hierarchy, as it is executed by the kernel.
				<br>
				Now in some applications, this is what you may want. You may want a reliable and battle tested process running as the init, especially on servers.
				<br>
				You may even want it on a desktop as well, for ease of use.
				<br>
				The biggest problem with being told what init to use and what not to use is that what works for others may not work for you.
				<br>
				<br>
				A lot of people have asked me what init they should use. The simplest answer, use the one that works. If systemd works for your system, why replace it?
				<br>
				On top of that, some distributions of Linux almost hard depend on systemd. For example, <a href="https://archlinux.org/" target="_blank">Arch Linux</a>, where the entire
				<br>
				system is built on the premise of using systemd. Packages that are installed have appropiate unit files for systemd. Replacing it, while it can be done,
				<br>
				is a tidious and quite annoying process.
				<br>
				<br>
				So all of this is to say: if you're the user who is new to *nix, and you don't know what init to use, don't change your init at all.
				<br>
				To quote a friend of mine, "<i>Linux users are all about freedom of choice, right up until someone's choice differs from theirs</i>."
				<br>
				<br>
				And on the opposite side of the spectrum, if you're the redbilled based user who is preaching to the newer, pure linux users:
				<br>
				<i>Shut the fuck up</i>. Let them learn the pros or cons of the software themselves. After all, for as much as I dislike systemd myself, <i>it just works</i>.
			</p>
		</article>
		<hr>
		<a id="0x06"></a>
		<article>
			<h3><span>0x06</span> &mdash; <i>a love letter to forums</i></h3>
			<p>
				Time goes on, technology is innovated upon, but when I was younger, I was enthralled by forums.
				<br>
				I don't know the particulars of it, but there's something oddly satisfying about creating a post on a board, and having to sit and refresh the page several times until you get a response.
				<br>
				<br>
				That's something that nowadays technology has taken from us.
				<br>
				Why would people want to sit on a forum, create a post asking how to fix a problem or spark some sort of conversation when they can go on Discord and get a response damn near instantly?
				<br>
				Call it what you want, patience, delayed gratification--whatever the case may be, forums have a certain charm to them.
				<br>
				And while I appreciate a good quick response from time to time, or a quick catch-up conversation with old friends over instant messaging,
				<br>
				I have a much larger appreciation for simple forums.
				<br>
				<br>
				In the forum community, it's hard to draw people in. It's hard to entice people to join in on something so primitive and outdated.
				<br>
				Maybe I just live in the past, but even today I still slay bits and bytes on good old bulletin boards.
				<br>
				Hell, if you look hard enough, you might even find forums that I'm still an active keyboard warrior on.
			</p>
		</article>
		<hr>
		<a id="0x05"></a>
		<article>
			<h3><span>0x05</span> &mdash; <i>a fictional story about timestamp gore</i></h3>
			<p>
				A long time ago, in a server far far away existed a web developer and a really interesting codebase. You are our savior in this story.
				<br>
				When you typically think of timestamps, chances are you think of a UNIX timestamp.
				<br>
				A 32-bit integer counting the amount of seconds that have passed since January 1st, 1970.
				<br>
				<br>
				Storing timestamps seems like a relatively painless endeavor, just allocate enough space for the timestamp, and you're off to the race(condition)s.
				<br>
				Except maybe it isn't the best implementation. I mean, some time in early 2038 UNIX timestamps will overflow, and we'll need to either switch to 64 bit or create a new epoch.
				<br>
				<br>
				It'll basically be Y2K all over again. 0x7fffffff16 will be our demise! Or will it?
				<br>
				Realistically speaking, likely not. What is more likely is developers will start implementing fixes for this overflow before it actually happens, and we won't be ill prepared.
				<br>
				<br>
				But what about another solution? What if we stored timestamps as a string?
				<br>
				Well, this can be an implementation, and depending on how scalable you want your timestamps to be, maybe the best way to deal with this kind of issue.
				<br>
				So, as a little bit of a thought experiment, if we did this, how much space would we need to allocate for our string?
				<br>
				<br>
				To calculate something like this, we'll need to make some assumptions. Typically, information on a website is stored in a database, and often times it's in SQL.
				<br>
				In a UTF8 encoded db, a single character is given 4 bytes of memory. If we use type varchar(32) to store a timestamp as a string, we'll have 128 bytes to work with.
				<br>
				128 bytes doesn't necessarily sound like a lot, but that's only for a single row. A single record.
				<br>
				If we say... store user data, to include when a user registered... Well, now we have N * 128 bytes of storage being taken up, where N is the amount of users, assuming we store no other information of course.
				<br>
				<br>
				You see where I'm going with this, right? So just 8 users deep, and all of the sudden we're taken up a kilobyte of storage for <i>just</i> timestamps.
				<br>
				By the way, do you like gore? I sure hope so.
				<br>
				Imagine for a moment that instead of storing a timestamp as a string in only a single column, we split up each part into its own dedicated column.
				<br>
				Let's be conservative and say that we give each indice... 6 characters to work with at most. And we'll say we only need the seconds, minutes, hours, days, months, and years.
				<br>
				Alright, we've got 6 columns, each of them have 6 characters. Remember, one single character takes up 4 bytes. 4 * 6 * 6. Now our timestamps take up 144 bytes.
				<br>
				<br>
				So given our algorithm of N * 144, we hit 1kb at just 7 users. Not that much of a difference, but we sure won't fucking scale well at all.
				<br>
				Now we're taking a metric ass-ton (abbreviated as AT) of space for <i>only</i> timestamps. We haven't even stored more than one, and we didn't calculate storage space for any other columns.
				<br>
				So by the time we add everything else back in, our user table is now taking up more than an AT. We're now taking kilo-ass-tons of storage space. kAT.
				<br>
				<br>
				So we're taking severak kATs of space, and we haven't even considered actual usage with this.
				<br>
				Time to query the database.
			</p>
			<pre>SELECT `seconds`,`minutes`,`hours`,`days`,`months`,`years`,`uid`,`username`,... FROM `pain_and_suffering.users` WHERE 1;</pre>
			<p>
				Could you imagine having to write that query several times over?
				<br>
				Don't worry, you don't have to, because in our fictional story, Bill did it for you.
				<br>
				Bill got fired by the way. Google didn't like how badly their database was running. And it's your lucky day, because site-wide, you get to fix this.
				<br>
				Oh, no, Google isn't running a query generator or anything. They haven't moved onto more modern technologies yet because they don't know how secure something like Laravel is or isn't.
				<br>
				<br>
				This might be a good time to mention that if we just used the datetime column type--which only uses 8 bytes--we would only be at N * 8. We'd hit 125 user records before we hit a kilobyte.
				<br>
				Just some food for thought; we haven't even hit a single AT of taken up storage space yet by using the datetime type.
				<br>
				<br>
				You've been tasked now with fixing every database query, as well as every bit of source code that deals with Bill's original database schema.
				<br>
				So what do you do? You start a transaction.
				<br>
				Time to write up a bit of code that iterates over every record in the database, parses each column related to time, concatenates it all, converts it to a proper UNIX timestamp,
				<br>
				stores it properly, then stores it in the database. Then you make sure everything is good, commit to the database, or rollback if not.
				<br>
				<br>
				Don't get me wrong; I'm not saying that storing a timestamp as a string is necessarily a bad thing, but don't be like Bill and assume it's going to be the best approach.
				<br>
				<br>
				Thankfully this story is <i>only</i> fictional. I pity the person who once had to, or one day will have to, fix this completely fictional issue.
				<br>
				Remember, kids, <i>sometimes the best approach is the one most used</i>. We don't all need to be innovators.
			</p>
		</article>
		<hr>
		<a id="0x04"></a>
		<article>
			<h3><span>0x04</span> &mdash; <i>close the window, i'm programming</i></h3>
			<p>
				You know, being in quite a few *nix customization communities, and also developing programs primarily for Linux, people often ask me, "Why the fuck do you use Windows?"
				<br>
				Don't worry, the irony is not lost on me. I may be smoov brane, but I'm not senile. Not yet at least.
				<br>
				<br>
				Now there's a lot of reasons I use it. The most common one I give is that <i>I think</i> linux is a waste of good hardware.
				<br>
				Take that how you will, but I've used linux for a <i>very</i> long time. That being the case though, as far back as I can remember using it, it was only ever prominently on old laptops or machines with weaker hardware.
				<br>
				Any average linux user will tell you it's because "linux gives your computer a performance boost!", which itself is wrong. Linux just doesn't use as many resources as another operating system, like Windows.
				<br>
				You have no actual performance gain as you otherwise would, it's just it seems like that to the end user because of these freed resources.
				<br>
				<br>
				The next reason is simply I don't like babysitting my system anymore. I think it may because I'm getting older as the days go on, but I don't like doing package management anymore,
				<br>
				I don't like having to go on a witch hunt for a bug and I can't use my shell anymore because I did a partial system upgrade, and now I have to burn it at the stake because bash depends on readline, and bash can't use the version of readline on my system.
				<br>
				It's mostly beyond me now, I've done it before, I'm tired of doing it, so I don't want to do it again.
				<br>
				<br>
				Next, I grew out of my customization phase. Don't get me wrong, I love doing desktop customization, and I do dabble in it every full blue moon, but that's only in passing now.
				<br>
				I no longer just sit down for hours on in trying to find the "optimal" setup. It's kind of like building a computer or working on a project car. You may get done with it, but it's never <i>complete</i>.
				<br>
				<br>
				Now if any of these reasons apply to you, that's completely fine. There's nothing wrong with having old hardware, nothing wrong with babysitting a system,
				<br>
				and there's nothing wrong with wanting to customize your system unless you use i3. These are just my reasons.
				<br>
				<br>
				This still begs the question though, "Sweets... you use Windows, yet you develop for Linux? What are you smoking, and where can I get some?"
				<br>
				To answer your second question, I'm not smoking no matter how hard that may be to believe, and then to answer your first, yes.
				<br>
				Alright, good talk. See you later.
				<br>
				<br>
				In all seriouesness, I still love Linux, despite not using it myself. I especially love developing for it because, simply, it's fun for me. There's no rhyme or reason.
				<br>
				I just enjoy it. And hopefully you or others enjoy using what I make. Even if you don't, at the end of the day, I program for fun (and thank fuck I don't program for a living now, I can tell some horror stories about that).
				<br>
				<br>
				So yeah, next time someone calls me a retard in a certain "down" Discord server, I'll just refer them here.
				<br>
				And if you're that person; go fuck yourself, there's nothing wrong with using Windows, despite what the insects living in your neckbeard tell you.
				<br>
				Also take a shower.
			</p>
		</article>
		<hr>
		<a id="0x03"></a>
		<article>
			<h3><span>0x03</span> &mdash; <i>help, i'm lost in walmart</i></h3>
			<p>
				After some bouncing of domains off of the forehead of a certain box, I've finally decided on what I want to call my blog.
				<br>
				A common tagline I've used on various social medias is "Help, I'm lost in Walmart."
				<br>
				This mostly stems from my inability to think up bios and such, but it's stuck for quite some time.
				<br>
				<br>
				So what better to call my blog than the lost in walmart blog? My blog isn't strictly tech related, just a blog for me to write whatever comes to mind.
				<br>
				<br>
				So officially; <i>help, I'm lost in Walmart</i>.
				<br>
				<br>
				On another note, you may notice in the top right a "previous" and "next" button.
				<br>
				The lost in walmart blog is part of a webcircle, the links go to various sites of my friends, and at some point, back here eventually.
				<br>
				Check out the other sites in the circle, I'm sure something that piques your interest can be found.
			</p>
		</article>
		<hr>
		<a id="0x02"></a>
		<article>
			<h3><span>0x02</span> &mdash; <i>__always_inline, linux, and musl</i></h3>
			<p>
				If you're trying to install <a href="https://k1sslinux.org" target="_blank">kiss linux</a> (or any non-glibc distribution) with a linux 5.x kernel, you may find that you'll run into an error trying to build the kernel.
			</p>
			<pre>/usr/include/linux/byteorder/little_endian.h:44:8: error: unknown type name '__always_inline'</pre>
			<p>
				On a system running glibc, this isn't particularly an issue; __always_inline is defined.
				<br>
				This isn't the case on systems that are using <a href="https://www.musl-libc.org/" target="_blank">musl</a> or other libc's though.
				<br>
				<br>
				So, as a quick fix, open up /usr/include/linux/swab.h in your flavor of text editor, and include linux/stddef.h just below linux/types.h.
			</p>
			<pre>#include &lt;linux/types.h&gt;
#include &lt;linux/stddef.h&gt;</pre>
			<p>
				With that, try to build again and you should be up an running.
				<br>
				Several PRs have been made in regards to this issue, so hopefully this will be fixed soon.
			</p>
		</article>
		<hr>
		<a id="0x01"></a>
		<article>
			<h3><span>0x01</span> &mdash; <i>pure of heart, dumb of ass</i></h3>
			<p>
				So this is my "blog" of sorts. A little about me, about the work I do, my system, etc.
				<br>
				<br>
				I'm Gray, I go by Sweets on the internet. I'm 21 years old, born in Texas, I now live in California.
				<br>
				My background is in full stack web development, though I don't work as a developer anymore, now I'm just a lowly C hobbyist.
				<br>
				Now I work as a microminiature repair technician. I solder super tiny circuits and shit.
				<br>
				<br>
				I believe in clean, readable code. I'm known for a various projects in *nix communities, <a href="https://github.com/Sweets/tiramisu" target="_blank">tiramisu</a>, <a href="https://github.com/Sweets/hummingbird" target="_blank">hummingbird</a>, and <a href="https://github.com/comfies/custard" target="_blank">custard</a> just to name a few.
				<br>
				<br>
				Some information on my systems, my desktop is a custom build that I've named "mercury".
				<br>
				I've got a Ryzen 9 3950x @ 4.5GHz, an RTX 2070 Super, Sabrent Rocket Q4 4TB, an Asus Strix B550-I, all housed within the beautiful <a href="https://formdworks.com/products/t1" target="=_blank">formd T1</a>.<br>
				My primary operating system is Windows 10, which is where I do all of my development. And yes, I see the irony in that.
				<br>
				My primary laptop is a 2021 MacBook Pro 13". The fancy M1 one because I have a bad habit of spending copious amounts of money on unnecessary hardware.
				<br><br>
				My other systems I use only for testing purposes. A Compaq Presario CQ57, a Toshiba Satellite C655, and an HP 14-dk0045nr,
				<br>
				running <a href="https://www.debian.org/" target="_blank">debian</a>, <a href="https://www.chromium.org/chromium-os" target="_blank">Chromium OS</a>, and <a href="https://k1sslinux.org" target="=_blank">KISS linux</a> respectively.
				<br><br>
 				Some communities that I frequent are r/<a href="https://reddit.com/r/unixporn" target="_blank">unixporn</a> and r/<a href="https://reddit.com/r/sffpc" target="_blank">sffpc</a>.
			</p>
		</article>
	</body>
</html>
