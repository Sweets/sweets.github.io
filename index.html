<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="description" content="lost in walmart blog">
		<title>lost in walmart blog</title>
		<link rel="stylesheet" type="text/css" href="/master.css">
	</head>
	<body>
		<header>
			<nav>
				<a href="#0x01">help, i'm lost in walmart</a>
				<a href="https://github.com/Sweets">github</a>
			</nav>
			<iframe sandbox="allow-scripts allow-top-navigation" loading=lazy src="https://circle.comfi.es/f/lost-in-walmart.blog/"></iframe>
		</header>
		<hr>
		<a id="0x05"></a>
		<article>
			<h3><span>0x05</span> &mdash; <i>a fictional story about web development gore</i></h3>
			<p>
				A long time ago, in a server far far away existed a web developer and a really interesting codebase. You are our savior in this story.
				<br>
				When you typically think of timestamps, chances are you think of a UNIX timestamp.
				<br>
				A 32-bit integer counting the amount of seconds that have passed since January 1st, 1970.
				<br>
				<br>
				Storing timestamps seems like a relatively painless endeavor, just allocate enough space for the timestamp, and you're off to the race(condition)s.
				<br>
				Except maybe it isn't the best implementation. I mean, some time in early 2038 UNIX timestamps will overflow, and we'll need to either switch to 64 bit or created a new epoch.
				<br>
				<br>
				It'll basically be Y2K all over again. 0x7fffffff16 will be our demise! Or will it?
				<br>
				Realistically speaking, likely not. What is more likely is developers will start implementing fixes for this overflow before it actually happens, and we won't be ill prepared.
				<br>
				<br>
				But what about another solution? What if we stored datetimes as a string?
				<br>
				Well, this can be an implementation, and depending on how scalable you want your timestamps to be, maybe the best way to deal with this kind of issue.
				<br>
				So, as a little bit of a thought experiment, if we did this, how much space would we need to allocate for our datetime string?
				<br>
				<br>
				To calculate something like this, we'll need to make some assumptions. Typically, information on a website is stored in a database, and often times it's in SQL.
				<br>
				In a UTF8 encoded db, a single character is given 4 bytes of memory. If we use type varchar(32) to store a timestamp as a string, we'll have 128 bytes to work with.
				<br>
				128 bytes doesn't necessarily sound like a lot, but that's only for a single row. A single record.
				<br>
				If we say... store user data, and when a user registered. Well, now we have N * 128 bytes of storage being taken up, where N is the amount of users, assuming we store no other datetimes of course.
				<br>
				<br>
				You see where I'm going with this, right? So just 8 users deep, and all of the sudden we're taken up a kb of storage for <i>just</i> timestamps.
				<br>
				By the way, do you like gore? I sure hope so.
				<br>
				Imagine for a moment that instead of storing a datetime as a string in only a single column, we split up each part into its own dedicated column.
				<br>
				Let's be conservative and say that we give each datetime indice... 8 characters to work with at most. And we'll say we only need the seconds, minutes, hours, days, months, and years.
				<br>
				Alright, we've got 6 columns, each of them have 6 characters. Remember, one single character takes up 4 bytes. 4 * 6 * 6. Now our single datetime takes 144 bytes.
				<br>
				<br>
				So given our algorithm of N * 144, we hit 1kb at just 7 users. Not that much of a difference, but we sure won't fucking scale well at all.
				<br>
				Now we're taking an ass-ton of space for <i>only</i> datetimes. We haven't even stored more than one, and we didn't calculate storage space for any other columns.
				<br>
				So by the time we add everything else back in, our user table is now taking up more than a metric ass-ton (abbreviated as AT). We're now taking kilo-ass-tons of storage space. kAT.
				<br>
				<br>
				So we're taking a kAT of space, and we haven't even considered actual usage with this.
				<br>
				Time to query the database.
			</p>
			<pre>SELECT `seconds`,`minutes`,`hours`,`days`,`months`,`years`,`uid`,`username`,... FROM `pain_and_suffering.users` WHERE 1;</pre>
			<p>
				Could you imagine having to write that query several times over?
				<br>
				Don't worry, you don't have to, because in our fictional story, Bill did it for you.
				<br>
				Bill got fired by the way. Google didn't like how badly their database was running. And it's your lucky day, because site-wide, you get to fix this.
				<br>
				Oh, no, Google isn't running a query generator or anything. They haven't moved onto more modern technologies yet because they don't know how secure something like Laravel is or isn't.
				<br>
				<br>
				This might be a good time to mention that if we just used the datetime column type--which only uses 8 bytes--we would only be at N * 8. We'd hit 125 user records before we hit a kilobyte.
				<br>
				Just some food for thought; we haven't even hit a single AT of taken up storage space yet by using the datetime type.
				<br>
				<br>
				You've been tasked now with fixing every database query, as well as every bit of source code that deals with Bill's original database schema.
				<br>
				So what do you do? You start a transaction.
				<br>
				Time to write up a bit of code that iterates over every record in the database, parses each column related to time, concatenates it all, converts it to a proper UNIX timestamp,
				<br>
				stores it properly, then commits it to the database. Then you make sure everything is good, commit to the database, or rollback if not.
				<br>
				<br>
				Don't get me wrong; I'm not saying that storing a timestamp as a string is necessarily a bad thing, but don't be like Bill and assume it's going to be the best approach.
				<br>
				<br>
				Thankfully this story is <i>only</i> fictional. I pity the person who once had to, or one day will have to, fix this completely fictional issue, that doesn't happen more than you'd think in web development.
				<br>
				Remember, sometimes the best approach is the one most used. We don't all need to be innovators.
			</p>
		</article>
		<a id="0x04"></a>
		<article>
			<h3><span>0x04</span> &mdash; <i>close the window, i'm programming</i></h3>
			<p>
				You know, being in quite a few *nix customization communities, and also developing programs primarily for Linux, people often ask me, "Why the fuck do you use Windows?"
				<br>
				Don't worry, the irony is not lost on me. I may be smoov brane, but I'm not senile. Not yet at least.
				<br>
				<br>
				Now there's a lot of reasons I use it. The most common one I give is that <i>I think</i> linux is a waste of good hardware.
				<br>
				Take that how you will, but I've used linux for a <i>very</i> long time. That being the case though, as far back as I can remember using it, it was only ever prominently on old laptops or machines with weaker hardware.
				<br>
				Any average linux user will tell you it's because "linux gives your computer a performance boost!", which itself is wrong. Linux just doesn't use as many resources as another operating system, like Windows.
				<br>
				You have no actual performance gain as you otherwise would, it's just it seems like that to the end user because of these freed resources.
				<br>
				<br>
				The next reason is simply I don't like babysitting my system anymore. I think it may because I'm getting older as the days go on, but I don't like doing package management anymore,
				<br>
				I don't like having to go on a witch hunt for a bug and I can't use my shell anymore because I did a partial system upgrade, and now I have to burn it at the stake because bash depends on readline, and bash can't use the version of readline on my system.
				<br>
				It's mostly beyond me now, I've done it before, I'm tired of doing it, so I don't want to do it again.
				<br>
				<br>
				Next, I grew out of my customization phase. Don't get me wrong, I love doing desktop customization, and I do dabble in it every full blue moon, but that's only in passing now.
				<br>
				I no longer just sit down for hours on in trying to find the "optimal" setup. It's kind of like building a computer or working on a project car. You may get done with it, but it's never <i>complete</i>.
				<br>
				<br>
				Now if any of these reasons apply to you, that's completely fine. There's nothing wrong with having old hardware, nothing wrong with babysitting a system,
				<br>
				and there's nothing wrong with wanting to customize your system unless you use i3. These are just my reasons.
				<br>
				<br>
				This still begs the question though, "Sweets... you use Windows, yet you develop for Linux? What are you smoking, and where can I get some?"
				<br>
				To answer your second question, I'm not smoking no matter how hard that may be to believe, and then to answer your first, yes.
				<br>
				Alright, good talk. See you later.
				<br>
				<br>
				In all seriouesness, I still love Linux, despite not using it myself. I especially love developing for it because, simply, it's fun for me. There's no rhyme or reason.
				<br>
				I just enjoy it. And hopefully you or others enjoy using what I make. Even if you don't, at the end of the day, I program for fun (and thank fuck I don't program for a living now, I can tell some horror stories about that).
				<br>
				<br>
				So yeah, next time someone calls me a retard in a certain "down" Discord server, I'll just refer them here.
				<br>
				And if you're that person; go fuck yourself, there's nothing wrong with using Windows, despite what the insects living in your neckbeard tell you.
				<br>
				Also take a shower.
			</p>
		</article>
		<hr>
		<a id="0x03"></a>
		<article>
			<h3><span>0x03</span> &mdash; <i>help, i'm lost in walmart</i></h3>
			<p>
				After some bouncing of domains off of the forehead of a certain box, I've finally decided on what I want to call my blog.
				<br>
				A common tagline I've used on various social medias is "Help, I'm lost in Walmart."
				<br>
				This mostly stems from my inability to think up bios and such, but it's stuck for quite some time.
				<br>
				<br>
				So what better to call my blog than the lost in walmart blog? My blog isn't strictly tech related, just a blog for me to write whatever comes to mind.
				<br>
				<br>
				So officially; <i>help, I'm lost in Walmart</i>.
				<br>
				<br>
				On another note, you may notice in the top right a "previous" and "next" button.
				<br>
				The lost in walmart blog is part of a webcircle, the links go to various sites of my friends, and at some point, back here eventually.
				<br>
				Check out the other sites in the circle, I'm sure something that piques your interest can be found.
			</p>
		</article>
		<hr>
		<a id="0x02"></a>
		<article>
			<h3><span>0x02</span> &mdash; <i>__always_inline, linux, and musl</i></h3>
			<p>
				If you're trying to install <a href="https://k1sslinux.org" target="_blank">kiss linux</a> (or any non-glibc distribution) with a linux 5.x kernel, you may find that you'll run into an error trying to build the kernel.
			</p>
			<pre>/usr/include/linux/byteorder/little_endian.h:44:8: error: unknown type name '__always_inline'</pre>
			<p>
				On a system running glibc, this isn't particularly an issue; __always_inline is defined.
				<br>
				This isn't the case on systems that are using <a href="https://www.musl-libc.org/" target="_blank">musl</a> or other libc's though.
				<br>
				<br>
				So, as a quick fix, open up /usr/include/linux/swab.h in your flavor of text editor, and include linux/stddef.h just below linux/types.h.
			</p>
			<pre>#include &lt;linux/types.h&gt;
#include &lt;linux/stddef.h&gt;</pre>
			<p>
				With that, try to build again and you should be up an running.
				<br>
				Several PRs have been made in regards to this issue, so hopefully this will be fixed soon.
			</p>
		</article>
		<hr>
		<a id="0x01"></a>
		<article>
			<h3><span>0x01</span> &mdash; <i>pure of heart, dumb of ass</i></h3>
			<p>
				So this is my "blog" of sorts. A little about me, about the work I do, my system, etc.
				<br>
				<br>
				I'm Grayson, I go by Sweets on the internet. I'm 20 years old, born in Texas, I now live in California.
				<br>
				My background is in full stack web development, though I don't work as a developer anymore, now I'm just a lowly C hobbyist.
				<br>
				Now I work as a microminiature repair technician. I solder super tiny circuits and shit.
				<br>
				<br>
				I believe in clean, readable code. I'm known for a various projects in *nix communities, <a href="https://github.com/Sweets/tiramisu" target="_blank">tiramisu</a>, <a href="https://github.com/Sweets/hummingbird" target="_blank">hummingbird</a>, and <a href="https://github.com/comfies/custard" target="_blank">custard</a> just to name a few.
				<br>
				<br>
				Some information on my system, my desktop is a custom build that I've named "mercury".
				<br>
				I've got a Ryzen 9 3950x @ 4.5GHz, an RTX 2070 Super, Sabrent Rocket Q4 4TB, an Asus Strix B550-I, all housed within the beautiful <a href="https://formdworks.com/products/t1" target="=_blank">formd T1</a>.<br>
				My primary operating system is Windows 10, which is where I do all of my development. And yes, I see the irony in that.
				<br>
				When I do use Linux, I use <a href="https://k1sslinux.org" target="=_blank">kiss linux</a> and <a href="https://www.debian.org/" target="_blank">debian</a>.
				<br>
				<br>
 				Some communities that I frequent are r/<a href="https://reddit.com/r/unixporn" target="_blank">unixporn</a> and r/<a href="https://reddit.com/r/sffpc" target="_blank">sffpc</a>.
			</p>
		</article>
	</body>
</html>
